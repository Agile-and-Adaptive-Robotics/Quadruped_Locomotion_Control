
Encoder_SPI.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800100  000001e6  0000027a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000001e6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000006  00800120  00800120  0000029a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000029a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000002cc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000030  00000000  00000000  00000308  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000074c  00000000  00000000  00000338  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000066a  00000000  00000000  00000a84  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000029d  00000000  00000000  000010ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000094  00000000  00000000  0000138c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000003dc  00000000  00000000  00001420  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000123  00000000  00000000  000017fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000020  00000000  00000000  0000191f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	19 c0       	rjmp	.+50     	; 0x34 <__ctors_end>
   2:	34 c0       	rjmp	.+104    	; 0x6c <__vector_1>
   4:	6f c0       	rjmp	.+222    	; 0xe4 <__vector_2>
   6:	31 c0       	rjmp	.+98     	; 0x6a <__bad_interrupt>
   8:	30 c0       	rjmp	.+96     	; 0x6a <__bad_interrupt>
   a:	2f c0       	rjmp	.+94     	; 0x6a <__bad_interrupt>
   c:	2e c0       	rjmp	.+92     	; 0x6a <__bad_interrupt>
   e:	2d c0       	rjmp	.+90     	; 0x6a <__bad_interrupt>
  10:	2c c0       	rjmp	.+88     	; 0x6a <__bad_interrupt>
  12:	2b c0       	rjmp	.+86     	; 0x6a <__bad_interrupt>
  14:	2a c0       	rjmp	.+84     	; 0x6a <__bad_interrupt>
  16:	29 c0       	rjmp	.+82     	; 0x6a <__bad_interrupt>
  18:	28 c0       	rjmp	.+80     	; 0x6a <__bad_interrupt>
  1a:	27 c0       	rjmp	.+78     	; 0x6a <__bad_interrupt>
  1c:	26 c0       	rjmp	.+76     	; 0x6a <__bad_interrupt>
  1e:	25 c0       	rjmp	.+74     	; 0x6a <__bad_interrupt>
  20:	24 c0       	rjmp	.+72     	; 0x6a <__bad_interrupt>
  22:	23 c0       	rjmp	.+70     	; 0x6a <__bad_interrupt>
  24:	22 c0       	rjmp	.+68     	; 0x6a <__bad_interrupt>
  26:	21 c0       	rjmp	.+66     	; 0x6a <__bad_interrupt>
  28:	20 c0       	rjmp	.+64     	; 0x6a <__bad_interrupt>
  2a:	1f c0       	rjmp	.+62     	; 0x6a <__bad_interrupt>
  2c:	1e c0       	rjmp	.+60     	; 0x6a <__bad_interrupt>
  2e:	1d c0       	rjmp	.+58     	; 0x6a <__bad_interrupt>
  30:	1c c0       	rjmp	.+56     	; 0x6a <__bad_interrupt>
  32:	1b c0       	rjmp	.+54     	; 0x6a <__bad_interrupt>

00000034 <__ctors_end>:
  34:	11 24       	eor	r1, r1
  36:	1f be       	out	0x3f, r1	; 63
  38:	cf ef       	ldi	r28, 0xFF	; 255
  3a:	d4 e0       	ldi	r29, 0x04	; 4
  3c:	de bf       	out	0x3e, r29	; 62
  3e:	cd bf       	out	0x3d, r28	; 61

00000040 <__do_copy_data>:
  40:	11 e0       	ldi	r17, 0x01	; 1
  42:	a0 e0       	ldi	r26, 0x00	; 0
  44:	b1 e0       	ldi	r27, 0x01	; 1
  46:	e6 ee       	ldi	r30, 0xE6	; 230
  48:	f1 e0       	ldi	r31, 0x01	; 1
  4a:	02 c0       	rjmp	.+4      	; 0x50 <__do_copy_data+0x10>
  4c:	05 90       	lpm	r0, Z+
  4e:	0d 92       	st	X+, r0
  50:	a0 32       	cpi	r26, 0x20	; 32
  52:	b1 07       	cpc	r27, r17
  54:	d9 f7       	brne	.-10     	; 0x4c <__do_copy_data+0xc>

00000056 <__do_clear_bss>:
  56:	21 e0       	ldi	r18, 0x01	; 1
  58:	a0 e2       	ldi	r26, 0x20	; 32
  5a:	b1 e0       	ldi	r27, 0x01	; 1
  5c:	01 c0       	rjmp	.+2      	; 0x60 <.do_clear_bss_start>

0000005e <.do_clear_bss_loop>:
  5e:	1d 92       	st	X+, r1

00000060 <.do_clear_bss_start>:
  60:	a6 32       	cpi	r26, 0x26	; 38
  62:	b2 07       	cpc	r27, r18
  64:	e1 f7       	brne	.-8      	; 0x5e <.do_clear_bss_loop>
  66:	7c d0       	rcall	.+248    	; 0x160 <main>
  68:	bc c0       	rjmp	.+376    	; 0x1e2 <_exit>

0000006a <__bad_interrupt>:
  6a:	ca cf       	rjmp	.-108    	; 0x0 <__vectors>

0000006c <__vector_1>:
volatile unsigned int enc_count0;
volatile unsigned int enc_count1;

static int lookup_table[] = {0,0,0,-1,0,0,1,0,0,1,0,0,-1,0,0,0}; // map change in encoder values to motion. use only one interrupt

ISR(INT0_vect) {
  6c:	1f 92       	push	r1
  6e:	0f 92       	push	r0
  70:	0f b6       	in	r0, 0x3f	; 63
  72:	0f 92       	push	r0
  74:	11 24       	eor	r1, r1
  76:	2f 93       	push	r18
  78:	3f 93       	push	r19
  7a:	8f 93       	push	r24
  7c:	9f 93       	push	r25
  7e:	ef 93       	push	r30
  80:	ff 93       	push	r31
	enc_val0 = enc_val0 << 2;						// leave space for new encoder reading
  82:	80 91 21 01 	lds	r24, 0x0121	; 0x800121 <enc_val0>
  86:	88 0f       	add	r24, r24
  88:	88 0f       	add	r24, r24
  8a:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <enc_val0>
	enc_val0 = enc_val0 | ((PIND & 0b1100) >> 2);	// drop new encoder values in the open space
  8e:	89 b1       	in	r24, 0x09	; 9
  90:	8c 70       	andi	r24, 0x0C	; 12
  92:	90 e0       	ldi	r25, 0x00	; 0
  94:	95 95       	asr	r25
  96:	87 95       	ror	r24
  98:	95 95       	asr	r25
  9a:	87 95       	ror	r24
  9c:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <enc_val0>
  a0:	89 2b       	or	r24, r25
  a2:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <enc_val0>
	
	enc_count0 = enc_count0 + lookup_table[enc_val0 & 0b1111]; // map the change in encoder values using the lookup table
  a6:	e0 91 21 01 	lds	r30, 0x0121	; 0x800121 <enc_val0>
  aa:	ef 70       	andi	r30, 0x0F	; 15
  ac:	f0 e0       	ldi	r31, 0x00	; 0
  ae:	ee 0f       	add	r30, r30
  b0:	ff 1f       	adc	r31, r31
  b2:	e0 50       	subi	r30, 0x00	; 0
  b4:	ff 4f       	sbci	r31, 0xFF	; 255
  b6:	20 81       	ld	r18, Z
  b8:	31 81       	ldd	r19, Z+1	; 0x01
  ba:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <enc_count0>
  be:	90 91 25 01 	lds	r25, 0x0125	; 0x800125 <enc_count0+0x1>
  c2:	82 0f       	add	r24, r18
  c4:	93 1f       	adc	r25, r19
  c6:	90 93 25 01 	sts	0x0125, r25	; 0x800125 <enc_count0+0x1>
  ca:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <enc_count0>
}
  ce:	ff 91       	pop	r31
  d0:	ef 91       	pop	r30
  d2:	9f 91       	pop	r25
  d4:	8f 91       	pop	r24
  d6:	3f 91       	pop	r19
  d8:	2f 91       	pop	r18
  da:	0f 90       	pop	r0
  dc:	0f be       	out	0x3f, r0	; 63
  de:	0f 90       	pop	r0
  e0:	1f 90       	pop	r1
  e2:	18 95       	reti

000000e4 <__vector_2>:

ISR(INT1_vect) {
  e4:	1f 92       	push	r1
  e6:	0f 92       	push	r0
  e8:	0f b6       	in	r0, 0x3f	; 63
  ea:	0f 92       	push	r0
  ec:	11 24       	eor	r1, r1
  ee:	2f 93       	push	r18
  f0:	3f 93       	push	r19
  f2:	8f 93       	push	r24
  f4:	9f 93       	push	r25
  f6:	ef 93       	push	r30
  f8:	ff 93       	push	r31
	enc_val1 = enc_val1 << 2;						// leave space for new encoder reading
  fa:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <__data_end>
  fe:	88 0f       	add	r24, r24
 100:	88 0f       	add	r24, r24
 102:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__data_end>
	enc_val1 = enc_val1 | ((PIND & 0b11000) >> 3);	// drop new encoder values in the open space
 106:	89 b1       	in	r24, 0x09	; 9
 108:	88 71       	andi	r24, 0x18	; 24
 10a:	90 e0       	ldi	r25, 0x00	; 0
 10c:	95 95       	asr	r25
 10e:	87 95       	ror	r24
 110:	95 95       	asr	r25
 112:	87 95       	ror	r24
 114:	95 95       	asr	r25
 116:	87 95       	ror	r24
 118:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <__data_end>
 11c:	89 2b       	or	r24, r25
 11e:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <__data_end>
	
	enc_count1 = enc_count1 + lookup_table[enc_val1 & 0b1111]; // map the change in encoder values using the lookup table
 122:	e0 91 20 01 	lds	r30, 0x0120	; 0x800120 <__data_end>
 126:	ef 70       	andi	r30, 0x0F	; 15
 128:	f0 e0       	ldi	r31, 0x00	; 0
 12a:	ee 0f       	add	r30, r30
 12c:	ff 1f       	adc	r31, r31
 12e:	e0 50       	subi	r30, 0x00	; 0
 130:	ff 4f       	sbci	r31, 0xFF	; 255
 132:	20 81       	ld	r18, Z
 134:	31 81       	ldd	r19, Z+1	; 0x01
 136:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <enc_count1>
 13a:	90 91 23 01 	lds	r25, 0x0123	; 0x800123 <enc_count1+0x1>
 13e:	82 0f       	add	r24, r18
 140:	93 1f       	adc	r25, r19
 142:	90 93 23 01 	sts	0x0123, r25	; 0x800123 <enc_count1+0x1>
 146:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <enc_count1>
}
 14a:	ff 91       	pop	r31
 14c:	ef 91       	pop	r30
 14e:	9f 91       	pop	r25
 150:	8f 91       	pop	r24
 152:	3f 91       	pop	r19
 154:	2f 91       	pop	r18
 156:	0f 90       	pop	r0
 158:	0f be       	out	0x3f, r0	; 63
 15a:	0f 90       	pop	r0
 15c:	1f 90       	pop	r1
 15e:	18 95       	reti

00000160 <main>:

int main (void) {
	
	// Set up a toggle pin
	DDRC |= (1 << PC5);
 160:	87 b1       	in	r24, 0x07	; 7
 162:	80 62       	ori	r24, 0x20	; 32
 164:	87 b9       	out	0x07, r24	; 7
	
	// SPI initialization
	DDRB |= (1 << DDB4);							//Set MISO as an output
 166:	84 b1       	in	r24, 0x04	; 4
 168:	80 61       	ori	r24, 0x10	; 16
 16a:	84 b9       	out	0x04, r24	; 4
	DDRB &= ~((1 << DDB3)|(1 << DDB5)|(1 << DDB2)); // Set MOSI, SCK, and SS pins as inputs (this step is redundant, but makes the code more readable).
 16c:	84 b1       	in	r24, 0x04	; 4
 16e:	83 7d       	andi	r24, 0xD3	; 211
 170:	84 b9       	out	0x04, r24	; 4

	SPCR = (1 << SPE); // SPI activation -- ATmega configured as peripheral
 172:	80 e4       	ldi	r24, 0x40	; 64
 174:	8c bd       	out	0x2c, r24	; 44
	
	// Encoder initialization
	EIMSK |= ((1 << INT0)|(1 << INT1)); // Activity on INT0 or INT1 triggers an interrupt
 176:	8d b3       	in	r24, 0x1d	; 29
 178:	83 60       	ori	r24, 0x03	; 3
 17a:	8d bb       	out	0x1d, r24	; 29
	EICRA |= ((1<<ISC00)|(1<<ISC10));  // Any logical change on INT0 or INT1 generates an interrupt request
 17c:	e9 e6       	ldi	r30, 0x69	; 105
 17e:	f0 e0       	ldi	r31, 0x00	; 0
 180:	80 81       	ld	r24, Z
 182:	85 60       	ori	r24, 0x05	; 5
 184:	80 83       	st	Z, r24
	
	sei();
 186:	78 94       	sei
	
	PORTC |= ~(1 << PC5);
 188:	88 b1       	in	r24, 0x08	; 8
 18a:	8f 6d       	ori	r24, 0xDF	; 223
 18c:	88 b9       	out	0x08, r24	; 8
	
	SPDR = 0x00; // Load MISO line. This might not be necessary
 18e:	1e bc       	out	0x2e, r1	; 46
	
	while (1) {

		if (SPSR & (1<<SPIF)) {
 190:	0d b4       	in	r0, 0x2d	; 45
 192:	07 fe       	sbrs	r0, 7
 194:	fd cf       	rjmp	.-6      	; 0x190 <main+0x30>
			
			PORTC ^= (1 << PC5); // toggle C5
 196:	98 b1       	in	r25, 0x08	; 8
 198:	80 e2       	ldi	r24, 0x20	; 32
 19a:	89 27       	eor	r24, r25
 19c:	88 b9       	out	0x08, r24	; 8
			
			char teensy_request = SPDR;
 19e:	8e b5       	in	r24, 0x2e	; 46
			
			if (teensy_request == 0xFF) {
 1a0:	8f 3f       	cpi	r24, 0xFF	; 255
 1a2:	31 f4       	brne	.+12     	; 0x1b0 <main+0x50>
				SPDR = enc_count0 >> 8;
 1a4:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <enc_count0>
 1a8:	30 91 25 01 	lds	r19, 0x0125	; 0x800125 <enc_count0+0x1>
 1ac:	3e bd       	out	0x2e, r19	; 46
 1ae:	07 c0       	rjmp	.+14     	; 0x1be <main+0x5e>
			} 
			else if (teensy_request == 0x0F) {
 1b0:	8f 30       	cpi	r24, 0x0F	; 15
 1b2:	29 f4       	brne	.+10     	; 0x1be <main+0x5e>
				SPDR = enc_count0 & 0xFF;
 1b4:	20 91 24 01 	lds	r18, 0x0124	; 0x800124 <enc_count0>
 1b8:	30 91 25 01 	lds	r19, 0x0125	; 0x800125 <enc_count0+0x1>
 1bc:	2e bd       	out	0x2e, r18	; 46
			}
			if (teensy_request == 0xEE) {
 1be:	8e 3e       	cpi	r24, 0xEE	; 238
 1c0:	31 f4       	brne	.+12     	; 0x1ce <main+0x6e>
				SPDR = enc_count1 >> 8;
 1c2:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <enc_count1>
 1c6:	90 91 23 01 	lds	r25, 0x0123	; 0x800123 <enc_count1+0x1>
 1ca:	9e bd       	out	0x2e, r25	; 46
 1cc:	e1 cf       	rjmp	.-62     	; 0x190 <main+0x30>
			} 
			else if (teensy_request == 0x0E) {
 1ce:	8e 30       	cpi	r24, 0x0E	; 14
 1d0:	31 f4       	brne	.+12     	; 0x1de <main+0x7e>
				SPDR = enc_count1 & 0xFF;
 1d2:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <enc_count1>
 1d6:	90 91 23 01 	lds	r25, 0x0123	; 0x800123 <enc_count1+0x1>
 1da:	8e bd       	out	0x2e, r24	; 46
 1dc:	d9 cf       	rjmp	.-78     	; 0x190 <main+0x30>
			}
			else {
				SPDR = 0x00;
 1de:	1e bc       	out	0x2e, r1	; 46
 1e0:	d7 cf       	rjmp	.-82     	; 0x190 <main+0x30>

000001e2 <_exit>:
 1e2:	f8 94       	cli

000001e4 <__stop_program>:
 1e4:	ff cf       	rjmp	.-2      	; 0x1e4 <__stop_program>
