# =============================
# Joint & Muscle Summary Plot (Generated with Copilot running ChatGPT-4.1)
# =============================
import os
import matplotlib.pyplot as plt
import numpy as np

# This plotter generated by ChatGPT
def plot_joint_muscle_summary(joint_ang, muscle_len, muscle_vel, muscle_ten, save_folder='python/fig_plots'):
    """
    For each joint, plot joint position, muscle length, velocity, and tension for both muscles.
    Save each plot as a PNG in the specified folder.
    """
    if not os.path.exists(save_folder):
        os.makedirs(save_folder)

    time = None
    # Assume all dicts have the same time axis length
    for joint in joint_ang:
        # Find corresponding muscles (assumes naming convention: joint in muscle name)
        muscles = [m for m in muscle_len if joint in m]
        if len(muscles) < 2:
            continue  # skip if not both muscles present
        m1, m2 = muscles[:2]
        n = len(joint_ang[joint])
        if time is None:
            time = np.arange(n)

        fig, axs = plt.subplots(4, 1, figsize=(8, 8), sharex=True)
        fig.suptitle(f"{joint.capitalize()} Summary", fontsize=16)

        axs[0].plot(time, joint_ang[joint], label=f"{joint} angle", color='tab:blue')
        axs[0].set_ylabel("Angle (rad)")
        axs[0].legend(loc='upper right')
        axs[0].grid(True, alpha=0.3)

        axs[1].plot(time, muscle_len[m1], label=f"{m1} length", color='tab:green')
        axs[1].plot(time, muscle_len[m2], label=f"{m2} length", color='tab:olive', linestyle='--')
        axs[1].set_ylabel("Length (mm)")
        axs[1].legend(loc='upper right')
        axs[1].grid(True, alpha=0.3)

        axs[2].plot(time, muscle_vel[m1], label=f"{m1} vel", color='tab:orange')
        axs[2].plot(time, muscle_vel[m2], label=f"{m2} vel", color='tab:red', linestyle='--')
        axs[2].set_ylabel("Velocity (mm/s)")
        axs[2].legend(loc='upper right')
        axs[2].grid(True, alpha=0.3)

        axs[3].plot(time, muscle_ten[m1], label=f"{m1} ten", color='tab:purple')
        axs[3].plot(time, muscle_ten[m2], label=f"{m2} ten", color='tab:pink', linestyle='--')
        axs[3].set_ylabel("Tension (N)")
        axs[3].set_xlabel("Time (index)")
        axs[3].legend(loc='upper right')
        axs[3].grid(True, alpha=0.3)

        plt.tight_layout(rect=[0, 0, 1, 0.97])
        fname = os.path.join(save_folder, f"{joint}_summary.png")
        plt.savefig(fname, dpi=150)
        plt.close(fig)
# =============================
# Imports & Dependencies
# =============================
import matplotlib
matplotlib.use('Agg')
import os
import sys
import math
import time as clock
import time as world_clock
import numpy as np
# import pandas as pd
import mujoco
import mujoco.viewer
import mediapy as media
import matplotlib.pyplot as plt
import scipy.signal
from scipy.signal import find_peaks
import serial
import threading
from queue import Queue
from sns_network_model import build_net, spike_net


# =============================
# Path Setup
# =============================
module_path = os.path.abspath(os.path.join('..'))
if module_path not in sys.path:
    sys.path.append(module_path)

def mujoco_model(xml_path):

    """
    Load and initialize a MuJoCo model from XML.
    Returns (model, data) tuple.
    """

    # load in the mujoco model and simulation
    model = mujoco.MjModel.from_xml_path(xml_path)
    data = mujoco.MjData(model)

    print("... MuJoCo Model Loaded")

    # set some initiial positions: left leg forward, right leg back
    # data.qpos[6] = -0.1
    # data.qpos[14] = 0.1
    # data.qpos[8] = -0.1
    # data.qpos[16] = 0.2

    mujoco.mj_forward(model,data)

    # for i in range(50):
    #     mujoco.mj_step(model, data)
    

    return model, data

def stim_to_act(stim):
    """
    Convert neural potential to muscle activation [0, 1].
    """
    # converted the stim2tenstion curve in animatlab
    steepness = 0.121465
    x_offset = -65
    y_offset = -0.002297
    amp = 1.0
    act = amp/(1 + np.exp(steepness*(x_offset-stim))) + y_offset
    return min(max(act, 0), 1)

def non_to_spk(x,half_point):
    """
    Convert neural potential to muscle activation [0, 1] (spiking version).
    """
    # converted the stim2tenstion curve in animatlab
    steepness = 0.121465
    y_offset = -0.002297
    amp = 3.5
    y = amp/(1 + np.exp(steepness*(half_point-x))) + y_offset

    # x1 = -100
    # x2 = -40
    # y1 = 0
    # y2 = 1

    # m = (y2-y1)/(x2-x1)
    # b = y1 - ((y2-y1)/(x2-x1)) * x1

    # y = m*x + b

    return min(max(y, 0), amp)

def plot_sns(time, data):
    """
    Plots a series of subplots for left and right side muscle activities using given time and data arrays.

    Plot left/right muscle activities for all limbs (SNS output).
    6x2 grid: each row = muscle group, columns = extensor/flexor.

                       2 - knee mn ext
                       3 - knee mn flx
                       4 - ankle mn ext
                       5 - ankle mn flx
                       6 - RG ext
                       7 - RG flx
                       8 - hip PF ext
                       9 - hip PF flx
                       10- KA PF ext
                       11- KA PF flx

                       Left Side
                       12 - hip mn ext
                       13 - hip mn flx
                       14 - knee mn ext
                       15 - knee mn flx
                       16 - ankle mn ext
                       17 - ankle mn flx
                       18 - RG ext
                       19 - RG flx
                       20 - hip PF ext
                       21 - hip PF flx
                       22 - KA PF ext
                       23 - KA PF flx

    Returns:
    None
    """

    left_hind_indices =  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11]
    right_hind_indices = [12,13,14,15,16,17,18,19,20,21,22,23]
    left_fore_indices =  [24,25,26,27,28,29,30,31,32,33,34,35]
    right_fore_indices = [36,37,38,39,40,41,42,43,44,45,46,47]
    
    titles_hind = ["Hip MNs", "Knee MNs", "Ankle MNs", "Hind RG HCs", "Hip PF HCs", "KA PF HCs"]
    titles_fore = ["Scapula MNs", "Shoulder/Elbow MNs", "Wrist MNs", "Fore RG HCs", "Scapula PF HCs", "SW PF HCs"]

    plt.figure(figsize=(15, 20))
    for i in range(int(len(left_hind_indices)/2)):
        # Left side plots
        plt.subplot(6, 2, 2*i + 1)
        plt.plot(time, data[left_hind_indices[2*i]], label='ext_muscle', color='red')
        plt.plot(time, data[left_hind_indices[2*i+1]], label='flx_muscle', color='green')
        plt.title(f'Right {titles_hind[i]}')
        plt.legend()

        # Right side plots
        plt.subplot(6, 2, 2*i + 2)
        plt.plot(time, data[right_hind_indices[2*i]], label='ext_muscle', color='red')
        plt.plot(time, data[right_hind_indices[2*i+1]], label='flx_muscle', color='green')
        plt.title(f'Left {titles_hind[i]}')
        plt.legend()

    plt.tight_layout()
    plt.savefig('python/fig_plots/plot_sns_hindlimbs.png')

    plt.figure(figsize=(15, 20))
    for i in range(int(len(left_hind_indices)/2)):
        # Left side fore plots
        plt.subplot(6, 2, 2*i + 1)
        plt.plot(time, data[left_fore_indices[2*i]], label='ext_muscle', color='red')
        plt.plot(time, data[left_fore_indices[2*i+1]], label='flx_muscle', color='green')
        plt.title(f'Left {titles_fore[i]}')
        plt.legend()

        # Right side fore plots
        plt.subplot(6, 2, 2*i + 2)
        plt.plot(time, data[right_fore_indices[2*i]], label='ext_muscle', color='red')
        plt.plot(time, data[right_fore_indices[2*i+1]], label='flx_muscle', color='green')
        plt.title(f'Right {titles_fore[i]}')
        plt.legend()

    plt.tight_layout()
    plt.savefig('python/fig_plots/plot_sns_forelimbs.png')

    # plt.figure()
    # plt.plot(time, data[])
    print("\n", "... SNS plots created")

def plot_spk(time, data):
    """
    Plots a series of subplots for left and right side muscle activities using given time and data arrays.
    Plot left/right muscle activities for all limbs (spiking output).
    6x2 grid: each row = muscle group, columns = extensor/flexor.

                       2 - knee mn ext
                       3 - knee mn flx
                       4 - ankle mn ext
                       5 - ankle mn flx

                       Left Side
                       6 - hip mn ext
                       7 - hip mn flx
                       8 - knee mn ext
                       9 - knee mn flx
                       10 - ankle mn ext
                       11 - ankle mn flx
                       
    Returns:
    None
    """
    
    left_hind_indices =  [0,  1,  2,  3,  4,  5 ]
    right_hind_indices = [6,  7,  8,  9,  10, 11]
    left_fore_indices =  [12, 13, 14, 15, 16, 17]
    right_fore_indices = [18, 19, 20, 21, 22, 23]
    titles_hind = ["Hip Spikerate", "Knee Spikerate", "Ankle Spikerate"]
    titles_fore = ["Scapula Spikerate", "Shoulder Spikerate", "Wrist Spikerate"]    


    ################### PLOT HINDLIMBS ###################
    plt.figure(figsize=(15, 10))
    
    for i in range(int(len(left_hind_indices)/2)):
    
        evens = 2*i

        ################## LEFT SIDE PLOTS ##################
        flx_spk_tms = np.where(data[left_hind_indices[evens+1]] == 1)[0]
        flx_spk_rts = np.zeros(len(flx_spk_tms)-1)
        for ii in range(len(flx_spk_rts)):
            flx_spk_rts[ii] = 1000 / (flx_spk_tms[ii+1] - flx_spk_tms[ii])

        ext_spk_tms = np.where(data[left_hind_indices[evens]] == 1)[0]
        ext_spk_rts = np.zeros(len(ext_spk_tms)-1)
        for ii in range(len(ext_spk_rts)):
            ext_spk_rts[ii] = 1000 / (ext_spk_tms[ii+1] - ext_spk_tms[ii])

        plt.subplot(3, 2, evens + 1)
        plt.plot(ext_spk_tms[1:], ext_spk_rts, label='ext_muscle', color='red', marker='o', linestyle='')
        plt.plot(flx_spk_tms[1:], flx_spk_rts, label='flx_muscle', color='green', marker='o', linestyle='')
        plt.title(f'Left {titles_hind[i]}')
        plt.legend()

        ################## RIGHT SIDE PLOTS ##################
        flx_spk_tms = np.where(data[right_hind_indices[evens+1]] == 1)[0]
        flx_spk_rts = np.zeros(len(flx_spk_tms)-1)
        for ii in range(len(flx_spk_rts)):
            flx_spk_rts[ii] = 1000 / (flx_spk_tms[ii+1] - flx_spk_tms[ii])

        ext_spk_tms = np.where(data[right_hind_indices[evens]] == 1)[0]
        ext_spk_rts = np.zeros(len(ext_spk_tms)-1)
        for ii in range(len(ext_spk_rts)):
            ext_spk_rts[ii] = 1000 / (ext_spk_tms[ii+1] - ext_spk_tms[ii])

        plt.subplot(3, 2, evens + 2)
        plt.plot(ext_spk_tms[1:], ext_spk_rts, label='ext_muscle', color='red', marker='o', linestyle='')
        plt.plot(flx_spk_tms[1:], flx_spk_rts, label='flx_muscle', color='green', marker='o', linestyle='')
        plt.title(f'Right {titles_hind[i]}')
        plt.legend()

    plt.savefig('python/fig_plots/plot_spk_hindlimbs.png')


    ################### PLOT FORELIMBS ###################
    plt.figure(figsize=(15, 10))

    for i in range(int(len(left_fore_indices)/2)):
    
        evens = 2*i

        ################## LEFT SIDE PLOTS ##################
        ext_spk_tms = np.where(data[left_fore_indices[evens]] == 1)[0]
        ext_spk_rts = np.zeros(len(ext_spk_tms)-1)
        for ii in range(len(ext_spk_rts)):
            ext_spk_rts[ii] = 1000 / (ext_spk_tms[ii+1] - ext_spk_tms[ii])

        flx_spk_tms = np.where(data[left_fore_indices[evens+1]] == 1)[0]
        flx_spk_rts = np.zeros(len(flx_spk_tms)-1)
        for ii in range(len(flx_spk_rts)):
            flx_spk_rts[ii] = 1000 / (flx_spk_tms[ii+1] - flx_spk_tms[ii])

        plt.subplot(3, 2, evens + 1)
        plt.plot(ext_spk_tms[1:], ext_spk_rts, label='ext_muscle', color='red', marker='o', linestyle='')
        plt.plot(flx_spk_tms[1:], flx_spk_rts, label='flx_muscle', color='green', marker='o', linestyle='')
        plt.title(f'Left {titles_fore[i]}')
        plt.legend()

        ################## RIGHT SIDE PLOTS ##################
        ext_spk_tms = np.where(data[right_fore_indices[evens]] == 1)[0]
        ext_spk_rts = np.zeros(len(ext_spk_tms)-1)
        for ii in range(len(ext_spk_rts)):
            ext_spk_rts[ii] = 1000 / (ext_spk_tms[ii+1] - ext_spk_tms[ii])

        flx_spk_tms = np.where(data[right_fore_indices[evens+1]] == 1)[0]
        flx_spk_rts = np.zeros(len(flx_spk_tms)-1)
        for ii in range(len(flx_spk_rts)):
            flx_spk_rts[ii] = 1000 / (flx_spk_tms[ii+1] - flx_spk_tms[ii])

        plt.subplot(3, 2, evens + 2)
        plt.plot(ext_spk_tms[1:], ext_spk_rts, label='ext_muscle', color='red', marker='o', linestyle='')
        plt.plot(flx_spk_tms[1:], flx_spk_rts, label='flx_muscle', color='green', marker='o', linestyle='')
        plt.title(f'Right {titles_fore[i]}')
        plt.legend()

    plt.savefig('python/fig_plots/plot_spk_forelimbs.png')

    print("... SPK plots created")

def isolate_cycle(t,vec):
    """
    Extract a single normalized gait cycle from a time series vector.
    Returns (time, single_gait) for one cycle, or zeros if extraction fails.
    """
    try:
        amp = np.max(1/(2+vec)) - np.min(1/(2+vec))
        start_cycle_inds = scipy.signal.find_peaks(1/(2+vec), prominence=0.05, distance=100)[0]
        middle_inds = int(len(start_cycle_inds) - 2)
        single_gait = vec[start_cycle_inds[middle_inds]  :  start_cycle_inds[middle_inds+1]-1]
        time = t[start_cycle_inds[middle_inds]  :  start_cycle_inds[middle_inds+1]-1]
        time = time - time[0]

        # print(t[start_cycle_inds[middle_inds]])
        # print(t[start_cycle_inds[middle_inds+1]-1])
        return time, single_gait - np.min(single_gait)
    
    except:
        return np.zeros(len(t)), np.zeros(len(t))
    
def calc_mse(x1, y1, x2, y2):
    y1_interp = np.interp(x2, x1, y1)
    mse = np.mean((y1_interp - y2)**2)
    return mse

def plot_gaits(time, joint_ang, savename=''):
    """
    Plot hip, knee, and ankle joint angles for all limbs, including single gait cycle and full simulation.
    Compares simulation to animal data.
    """

    R_hip_time, R_hip_gait = isolate_cycle(time, joint_ang['R_hip_joint'])
    R_knee_time, R_knee_gait = isolate_cycle(time, joint_ang['R_knee_joint'])
    R_ankle_time, R_ankle_gait = isolate_cycle(time, joint_ang['R_ankle_joint'])

    # max_len = min([len(R_hip_time), len(R_knee_time), len(R_ankle_time)])

    # save_data = {'hip_t': R_hip_time[:max_len], 
    #              'hip_gait': R_hip_gait[:max_len],
    #              'knee_t': R_knee_time[:max_len], 
    #              'knee_gait': R_knee_gait[:max_len],
    #              'ankle_t': R_ankle_time[:max_len], 
    #              'ankle_gait': R_ankle_gait[:max_len]}
    # df = pd.DataFrame(save_data)
    # df.to_csv('two_layer_gait.csv',index=False)

    L_hip_time, L_hip_gait = isolate_cycle(time, joint_ang['L_hip_joint'])
    L_knee_time, L_knee_gait = isolate_cycle(time, joint_ang['L_knee_joint'])
    L_ankle_time, L_ankle_gait = isolate_cycle(time, joint_ang['L_ankle_joint'])

    # load in the animal data
    anim_data = np.loadtxt('python/JA.csv', delimiter=',')
    anim_time = anim_data[:,0]
    anim_time = anim_time - anim_time[0]
    # hip trajectory
    anim_hip = anim_data[:,1]  - np.min(anim_data[:,1])
    min_index = np.argmin(anim_hip)
    anim_hip = np.concatenate((anim_hip[min_index:], anim_hip[:min_index]))*np.pi/180
    # knee
    anim_knee = (anim_data[:,2] - np.min(anim_data[:,2]))*np.pi/180
    # ankle
    anim_ankle = anim_data[:,3] - np.min(anim_data[:,3])
    min_index = np.argmin(anim_ankle)
    anim_ankle = np.concatenate((anim_ankle[min_index:], anim_ankle[:min_index]))*np.pi/180

    # print('Animal Gait Time: ', anim_time[-1])
    # print('Sim Gait Time:    ', R_hip_time[-1])

    hip_mse = round(calc_mse(anim_time, anim_hip, R_hip_time, R_hip_gait),5)
    knee_mse = round(calc_mse(anim_time, anim_knee, R_knee_time, R_knee_gait),5)
    ankle_mse = round(calc_mse(anim_time, anim_ankle, R_ankle_time, R_ankle_gait),5)

    # print('Hip MSE:   ', hip_mse)
    # print('Knee MSE:  ', knee_mse)
    # print('Ankle MSE: ', ankle_mse)

    hip_amp_error = 10*abs(max(anim_hip) - max(R_hip_gait))  
    cost = np.array([hip_mse, knee_mse, ankle_mse, hip_amp_error]) 
    
    # print(cost) 

    # print(anim_time[-1])
    # print(R_hip_time[-1])
    # print(R_knee_time[-1])
    # print(R_ankle_time[-1])

    plt.figure(figsize=(20,5))
    plt.subplot(1,3,1)
    plt.plot(anim_time, anim_hip, 'r-.', label='Animal Data')
    plt.plot(R_hip_time, R_hip_gait,  'b-', label='Sim Data R')
    plt.plot(L_hip_time, L_hip_gait,  color='green', ls='--', label='Sim Data L')
    plt.title('Hip Trajectory')
    plt.ylabel('Angle (rad)')
    plt.xlabel('Time (s)')
    legend = plt.legend(loc='upper left')
    legend.get_frame().set_alpha(1.0)

    plt.subplot(1,3,2)
    plt.plot(anim_time, anim_knee, 'r-.', label='Animal Data')
    plt.plot(R_knee_time, R_knee_gait,  'b-', label='Sim Data_R')
    plt.plot(L_knee_time, L_knee_gait,  color='green', ls='--', label='Sim Data L')
    plt.title('Knee Trajectory')
    plt.ylabel('Angle (rad)')
    plt.xlabel('Time (s)')
    legend = plt.legend(loc='upper left')
    legend.get_frame().set_alpha(1.0)

    plt.subplot(1,3,3)
    plt.plot(anim_time, anim_ankle, 'r-.', label='Animal Data')
    plt.plot(R_ankle_time, R_ankle_gait,  'b-', label='Sim Data_R')
    plt.plot(L_ankle_time, L_ankle_gait,  color='green', ls='--', label='Sim Data L')
    plt.title('Ankle Trajectory')
    plt.ylabel('Angle (rad)')
    plt.xlabel('Time (s)')
    legend = plt.legend(loc='upper left')
    legend.get_frame().set_alpha(1.0)


    plt.figure(figsize=(15,10))
    for joint in joint_ang.keys():
        if 'L' in joint:
            label = 'Left'
        else:
            label = 'Right'
        
        if 'hip' in joint:
            plt.subplot(3,1,1)
        elif 'knee' in joint:
            plt.subplot(3,1,2)
        else:
            plt.subplot(3,1,3)
        
        plt.plot(time, joint_ang[joint], label=label)
        plt.title(joint.split('_')[-1].capitalize()+' Position')
        plt.ylabel('Joint Angle (rad)')

    plt.subplot(3,1,1)
    plt.legend()
    plt.subplot(3,1,3)
    plt.xlabel('Time (s)')

    # plt.savefig(savename+'.png', bbox_inches='tight')

    if any(cost == 0.0):
        return 10
    else:
        return sum(cost)
    
    plt.savefig('plot_gaits.png')
    print("... Gait plots created")

def plot_length(time, muscle_len):
    """
    Plot muscle length traces for all muscles.
    """
    plt.figure(figsize=(20,5))
    for muscle in muscle_len.keys():
        plt.plot(muscle_len[muscle],'.', label=muscle)
    plt.legend()
    plt.savefig('python/fig_plots/muscle_len.png')
    print("... Muscle length plots created")

def plot_velocity(time, muscle_vel):
    """
    Plot muscle velocity traces for all muscles.
    """
    plt.figure(figsize=(20,5))
    for muscle in muscle_vel.keys():
        plt.plot(muscle_vel[muscle],'.', label=muscle)
    plt.legend()
    plt.savefig('python/fig_plots/muscle_vel.png')
    print("... Muscle velocity plots created")

def plot_joint(time, joint_ang):
    """
    Plot left hip joint angle trace and save to file.
    """
    # Define joint groupings for each leg
    leg_joints = {
        'Left Forelimb':   ['L_scapula_joint', 'L_shoulder_joint', 'L_wrist_joint'],
        'Right Forelimb':  ['R_scapula_joint', 'R_shoulder_joint', 'R_wrist_joint'],
        'Left Hindlimb':   ['L_hip_joint', 'L_knee_joint', 'L_ankle_joint'],
        'Right Hindlimb':  ['R_hip_joint', 'R_knee_joint', 'R_ankle_joint'],
    }
    fig, axs = plt.subplots(2, 2, figsize=(18, 10), sharex=True)
    leg_titles = list(leg_joints.keys())
    for idx, (leg, joints) in enumerate(leg_joints.items()):
        ax = axs[idx // 2, idx % 2]
        for joint in joints:
            if joint in joint_ang:
                ax.plot(joint_ang[joint], '.', label=joint)
        ax.set_title(leg)
        ax.set_ylabel('Joint Angle (rad)')
        ax.legend()
    axs[1,0].set_xlabel('Time (samples)')
    axs[1,1].set_xlabel('Time (samples)')
    plt.tight_layout()
    import os
    os.makedirs('python/fig_plots', exist_ok=True)
    plt.savefig('python/fig_plots/joint_ang.png', bbox_inches='tight', dpi=150)
    np.savetxt("python/fig_plots/joint_ang.txt", joint_ang['L_hip_joint'], fmt="%.4f")
    print("... Joint angle plots created")


def plot_times(times):
    """
    Prints the times it took to run each section of the code throughout the simulation.
    Makes a pie chart of these times. 

    Parameters:
    times (array-like): An array of time points. 
                        t_init, t_sns, t_mujoco, t_sns2mujoco, t_mujoco2sns, t_plot, t_video = times
                        t_init:       time to initialize and compile models
                        t_sns:        time in sns-toolbox running the nueral model. Does not include compiling the model
                        t_mujoco:     time running the phisics model. Does not include compiling the model
                        t_sns2mujoco: time calculating the muscle activations from motor neuron data
                        t_mujoco2sns: time computing the feedback from biomechanical to neural model
                        t_plot:       time devoted to plotting the joint and neural data
                        t_video:      time devoted to making the video of the biomechanical model

    Returns:
    None
    """
    time_print, time_sns, time_spk, time_spkqueue, time_mujo, time_feed, time_vid, time_loop = times
    labels = ['Print-to-Terminal', 'SNS-Toolox', 'SNS-Spike Creation' 'Add-to-Spike Queue', 'MuJoCo', 'Feedback Processing', 'Video Creation']
    print('\n','Print-to-Terminal Time:          ', round(time_print,4))
    print('SNS-Toolox Time:                 ', round(time_sns,4))
    print('SNS-Toolox Spk Time:             ', round(time_spk,4))
    print('Add-to-Spike Queue Time:         ', round(time_spkqueue,4))
    print('MuJoCo Time:                     ', round(time_mujo,4))
    print('Feedback Processing Time:        ', round(time_feed,4))
    print('Video Creation Time:             ', round(time_vid,4))
    print('Total Loop Time:                 ', round(time_print+time_sns+time_spk+time_spkqueue+time_mujo+time_feed+time_vid,4))
    print('Total Loop Time (check):         ', round(time_loop,4))
    
    plt.figure()  # Optional: adjust the figure size
    plt.pie(times[0:6], labels=labels, autopct='%1.1f%%', startangle=140)
    plt.title('Sim Loop Time Distribution')
    plt.axis('equal')

    plt.savefig('python/fig_plots/plot_times.png')

# def save_data(muscle_len, muscle_vel, muscle_ten):
#     # sns_data outputs: should be 24
#     # Right Side
#     # 0 - hip mn ext
#     # 1 - hip mn flx
#     # 2 - knee mn ext
#     # 3 - knee mn flx
#     # 4 - ankle mn ext
#     # 5 - ankle mn flx
#     # 6 - RG ext
#     # 7 - RG flx
#     # 8 - hip PF ext
#     # 9 - hip PF flx
#     # 10- KA PF ext
#     # 11- KA PF flx

#     # Left Side
#     # 12 - hip mn ext
#     # 13 - hip mn flx
#     # 14 - knee mn ext
#     # 15 - knee mn flx
#     # 16 - ankle mn ext
#     # 17 - ankle mn flx
#     # 18 - RG ext
#     # 19 - RG flx
#     # 20 - hip PF ext
#     # 21 - hip PF flx
#     # 22 - KA PF ext
#     # 23 - KA PF flx

#     sns_headers = ['R_hip_MN_Ext', 'R_hip_MN_Flx', 'R_knee_MN_Ext', 'R_knee_MN_Flx', 'R_ankle_MN_Ext', 'R_ankle_MN_Flx', 'R_RG_Ext', 'R_RG_Flx', 'R_hip_PF_Ext', 'R_hip_PF_Flx', 'R_KA_PF_Ext', 'R_KA_PF_Flx',
#                'L_hip_MN_Ext', 'L_hip_MN_Flx', 'L_knee_MN_Ext', 'L_knee_MN_Flx', 'L_ankle_MN_Ext', 'L_ankle_MN_Flx', 'L_RG_Ext', 'L_RG_Flx', 'L_hip_PF_Ext', 'L_hip_PF_Flx', 'L_KA_PF_Ext', 'L_KA_PF_Flx']
    
#     # sns_df = pd.DataFrame(sns_data, columns=sns_headers)

#     # joint_df = pd.DataFrame(joint_ang)
#     muscle_len_df = pd.DataFrame(muscle_len)
#     muscle_vel_df = pd.DataFrame(muscle_vel)
#     muscle_ten_df = pd.DataFrame(muscle_ten)

#     base_folder = 'feedback_test/'

#     # sns_df.to_csv(base_folder+'sns_data.csv', index=False)
#     # joint_df.to_csv(base_folder+'joint_ang.csv', index=False)
#     muscle_len_df.to_csv(base_folder+'muscle_length.csv', index=False)
#     muscle_vel_df.to_csv(base_folder+'muscle_velocity.csv', index=False)
#     muscle_ten_df.to_csv(base_folder+'muscle_tension.csv', index=False)

#     print("... Data saved")
    
def vel2S(vel):
    return 4.3*np.sign(vel)*(np.abs(vel)**(0.6)) + 82

def hip_inputs(length_e, length_f, velocity_e, velocity_f, tension_e, tension_f, L0_e, L0_f):
    Ia_e = vel2S(velocity_e)*10 -820
    Ia_f = vel2S(velocity_f)*10 -820
    Ib_e = tension_e*(-2) -1
    Ib_f = tension_f*(-2) -1
    II_e = (length_e - L0_e) *1000 +1
    II_f = (length_f - L0_f) *1000

    return np.array([Ia_e, Ia_f, Ib_e, Ib_f, II_e, II_f])

def knee_inputs(length_e, length_f, velocity_e, velocity_f, tension_e, tension_f, L0_e, L0_f):
    Ia_e = vel2S(velocity_e)*10 -820
    Ia_f = vel2S(velocity_f)*10 -820
    Ib_e = tension_e*(-1)-1
    Ib_f = tension_f*(-5)-1
    # II_e = (length_e - L0_e) *2000 -2.75
    # II_f = (length_f - L0_f) *500  +3

    return np.array([Ia_e, Ia_f, Ib_e, Ib_f])

def ankle_inputs(length_e, length_f, velocity_e, velocity_f, tension_e, tension_f, L0_e, L0_f):
    Ia_e = vel2S(velocity_e)*10 -820
    Ia_f = vel2S(velocity_f)*10 -820
    Ib_e = tension_e*(-1)-1
    Ib_f = tension_f*(-3)-1
    # II_e = (length_e - L0_e) *10000 -5.5
    II_f = (length_f - L0_f) *7000  +7

    return np.array([Ia_e, Ia_f, Ib_e, Ib_f, II_f])

def scapula_inputs(length_e, length_f, velocity_e, velocity_f, tension_e, tension_f, L0_e, L0_f):
    Ia_e = vel2S(velocity_e)*10 -820
    Ia_f = vel2S(velocity_f)*10 -820
    Ib_e = tension_e*(-2) -1
    Ib_f = tension_f*(-2) -1
    II_e = (length_e - L0_e) *2000 +1
    II_f = (length_f - L0_f) *2000

    return np.array([Ia_e, Ia_f, Ib_e, Ib_f, II_e, II_f])

def shoulder_inputs(length_e, length_f, velocity_e, velocity_f, tension_e, tension_f, L0_e, L0_f):
    Ia_e = vel2S(velocity_e)*10 -820
    Ia_f = vel2S(velocity_f)*10 -820
    Ib_e = tension_e*(-1)-1
    Ib_f = tension_f*(-5)-1
    # II_e = (length_e - L0_e) *2000 -2.75
    # II_f = (length_f - L0_f) *500  +3

    return np.array([Ia_e, Ia_f, Ib_e, Ib_f])

def wrist_inputs(length_e, length_f, velocity_e, velocity_f, tension_e, tension_f, L0_e, L0_f):
    Ia_e = vel2S(velocity_e)*10 -820
    Ia_f = vel2S(velocity_f)*10 -820
    Ib_e = tension_e*(-1)-1
    Ib_f = tension_f*(-3)-1
    # II_e = (length_e - L0_e) *10000 -5.5
    II_f = (length_f - L0_f) *7000  +7

    return np.array([Ia_e, Ia_f, Ib_e, Ib_f, II_f])

def muscle_data(
    potentiometer_data_0,
    potentiometer_data,
    joint_ang,
    muscle_len,
    muscle_vel,
    muscle_ten,
    comm_dt,
    comm_index,
    joint_diam,
    muscle_L0,
    pressure_sensor_data_0,
    pressure_sensor_data):

    """
    Updates joint angle, muscle length, velocity, and tension dictionaries in place
    based on potentiometer and pressure sensor readings.
    """
    comm_index = int(comm_index)  # Ensure comm_index is an integer
    convert = (3/2 * np.pi) / 255  # TODO: Measure this

    # Update joint angles
    for joint in joint_ang.keys():
        angle = (int(potentiometer_data[joint]) - int(potentiometer_data_0[joint])) * convert
        joint_ang[joint][comm_index] = angle

    # Update muscle lengths
    for muscle in muscle_len.keys():
        # Find which joint this muscle crosses (assumes naming convention)
        for joint in joint_ang.keys():
            if joint in muscle:
                if 'L_' in joint:
                    if 'wrist' or 'ankle' or 'scapula' or 'hip' in joint:
                        offset = joint_ang[joint][comm_index] * (joint_diam[joint] / 2)
                    elif 'shoulder' or 'knee' in joint:
                        offset = - joint_ang[joint][comm_index] * (joint_diam[joint] / 2)
                    else:
                        print("Unidentifiable L_ joint in offset calculation.", file = sys.stderr)
                if 'R_' in joint:
                    if 'wrist' or 'ankle' or 'scapula' or 'hip' in joint:
                        offset = - joint_ang[joint][comm_index] * (joint_diam[joint] / 2)
                    elif 'shoulder' or 'knee' in joint:
                        offset = joint_ang[joint][comm_index] * (joint_diam[joint] / 2)
                    else:
                        print("Unidentifiable R_ joint in offset calculation.", file = sys.stderr)
                if 'flx' in muscle:
                    antagonist_muscle = muscle.replace('flx', 'ext')
                    muscle_len[muscle][comm_index]            = muscle_L0[muscle]            + offset
                    muscle_len[antagonist_muscle][comm_index] = muscle_L0[antagonist_muscle] - offset

    # Update muscle velocities (second order backwards difference approximation to remove noise. requires index > 1)
    if comm_index > 1:
        for muscle in muscle_vel.keys():
            muscle_vel[muscle][comm_index] = (3 * muscle_len[muscle][comm_index] - 4 * muscle_len[muscle][comm_index - 1] + muscle_len[muscle][comm_index - 2]) / (2 * comm_dt)
    else:
        for muscle in muscle_vel.keys():
            muscle_vel[muscle][comm_index] = 0.0

    # Update muscle tensions from pressure sensor
    for muscle in muscle_ten.keys():
        muscle_ten[muscle][comm_index] = int(pressure_sensor_data[muscle]) - int(pressure_sensor_data_0[muscle])

    return





def run_sims(dt, 
             num_steps, 
             end_time, 
             comm_freq,
             num_comms,
             xml_path, 
             cpg_inputs, 
             cpg_gsyn=1.49167, 
             feed_forward=True,
             muscle_mutt=False,
             make_vid=True,
             spike_port_name='name_goes_here',
             sense_port_name='name_goes_here'):
    """
    Runs a simulation integrating a neural network model (SNS toolbox) with a Mujoco physics engine model.

    Parameters:
    dt (float): Time step for the simulation in seconds.
    num_steps (int): Number of simulation steps to run.
    xml_path (str): Path to the Mujoco XML model file.
    L_cpg_inputs (ndarray): Left CPG inputs for each simulation step.
    R_cpg_inputs (ndarray): Right CPG inputs for each simulation step.
    save_name (str): Base name for saving simulation outputs (optional).

    Returns:
    None

    This function integrates the SNS toolbox neural network model with Mujoco physics simulations over a specified 
    number of time steps. It calculates and records joint positions, muscle lengths, forces, and velocities, and can 
    optionally generate a video and plot simulations.
    """

    '''
    We want the simulation to run fast, such that errors are not created. However, we only want to send spikes in batches.
    Spikes are "and"ed on to each other and send at 50 Hz.
    '''

    # ----------------------
    # Initialization Section
    # ----------------------

    # --- Timing and Communication ---
    comm_dt    = 1 / comm_freq       # Communication period (s)
    comm_index = 0               # Communication event counter

    # --- Simulation Time Vectors ---
    t = np.arange(0, num_steps)
    time = np.zeros([len(t)])

    # --- Teensy/Serial Initialization ---
    if muscle_mutt:
        spike_port = serial.Serial(port=spike_port_name, baudrate=9600, timeout=0.1)
        sense_port = serial.Serial(port=sense_port_name, baudrate=9600, timeout=0.1)
        print("... Teensy Connection Established")

        spike_port.reset_input_buffer()  # Clear any existing data in the buffer
        spike_port.reset_output_buffer() # Clear any existing data in the buffer
        sense_port.reset_input_buffer()  # Clear any existing data in the buffer
        sense_port.reset_output_buffer() # Clear any existing data in the buffer    
    else:
        pulse_data = np.zeros([len(t), num_spk_out])   # Simulated Teensy pulse data
        pulse_data[0] = np.zeros([num_spk_out])        # For comparison with physical platform

    # --- MuJoCo and SNS Model Initialization ---
    mujoco_dt = dt
    sns_dt = mujoco_dt * 1000
    mujoco_sim, mujoco_data = mujoco_model(xml_path)
    mujoco_sim.opt.timestep = mujoco_dt
    sns_model = build_net(dt=sns_dt, cpg_gsyn=cpg_gsyn, feed_forward=feed_forward)
    spk_model = spike_net(dt=sns_dt) # Nonspiking to spiking conversion network

    # --- SNS Data Structures ---
    num_outputs = sns_model.num_outputs
    sns_sim_data = np.zeros([len(t), num_outputs])
    sns_sim_data[0] = [-100.0, -100.0, -100.0, -100.0, -100.0, -100.0, -60, -60, -60, -60, -60, -60, 
                       -100.0, -100.0, -100.0, -100.0, -100.0, -100.0, -60, -60, -60, -60, -60, -60,
                       -100.0, -100.0, -100.0, -100.0, -100.0, -100.0, -60, -60, -60, -60, -60, -60, 
                       -100.0, -100.0, -100.0, -100.0, -100.0, -100.0, -60, -60, -60, -60, -60, -60]
    num_spk_out = spk_model.num_outputs
    sns_spk_data = np.zeros([len(t), num_spk_out])
    sns_spk_data[0] = np.zeros([num_spk_out])
    num_inputs   = int(sns_model.num_inputs)
    sns_inputs   = np.concatenate([np.zeros(num_inputs-1), [0]])
    num_spk_in   = int(spk_model.num_inputs)
    spk_inputs   = np.concatenate([np.zeros(num_spk_in)])

    # --- Muscle and Joint Initialization ---
    muscles_list = [mujoco.mj_id2name(mujoco_sim, mujoco.mjtObj.mjOBJ_ACTUATOR, i) for i in range(mujoco_sim.nu)]
    all_joint_names = [mujoco.mj_id2name(mujoco_sim, mujoco.mjtObj.mjOBJ_JOINT, i) for i in range(mujoco_sim.njnt)]
    joint_list = [name for name in all_joint_names if any(keyword in name for keyword in ['hip', 'knee', 'ankle', 'scapula', 'shoulder', 'wrist'])]
    joint_indices  = {name: mujoco.mj_name2id(mujoco_sim, mujoco.mjtObj.mjOBJ_JOINT, name)    for name in  joint_list}
    muscle_indices = {name: mujoco.mj_name2id(mujoco_sim, mujoco.mjtObj.mjOBJ_ACTUATOR, name) for name in  muscles_list}

    print(joint_list)
    print(muscles_list)

    # --- Raw Robot Data Structures ---
    potentiometer_data      = {key: 0 for key in joint_list}
    potentiometer_data_0    = {key: 0 for key in joint_list}
    pressure_sensor_data    = {key: 0 for key in muscles_list}
    pressure_sensor_data_0  = {key: 0 for key in muscles_list}

    # --- Joint/Muscle Data Arrays ---

    # --- Muscle Properties ---
    if muscle_mutt:
        joint_ang  = {key: np.zeros(num_comms) for key in joint_list}
        muscle_len = {key: np.zeros(num_comms) for key in muscles_list}
        muscle_vel = {key: np.zeros(num_comms) for key in muscles_list}
        muscle_ten = {key: np.zeros(num_comms) for key in muscles_list}

        muscle_L0 = {name: 0.3 for name in muscles_list}
        for muscle in muscle_L0:
            if   'hip_joint_flx_muscle' in muscle:        muscle_L0[muscle] = 0.4
            elif 'hip_joint_ext_muscle' in muscle:        muscle_L0[muscle] = 0.4
            elif 'knee_joint_flx_muscle' in muscle:       muscle_L0[muscle] = 0.4
            elif 'knee_joint_ext_muscle' in muscle:       muscle_L0[muscle] = 0.4
            elif 'ankle_joint_flx_muscle' in muscle:      muscle_L0[muscle] = 0.4
            elif 'ankle_joint_ext_muscle' in muscle:      muscle_L0[muscle] = 0.4
            elif 'scapula_joint_flx_muscle' in muscle:    muscle_L0[muscle] = 0.4
            elif 'scapula_joint_ext_muscle' in muscle:    muscle_L0[muscle] = 0.4
            elif 'shoulder_joint_flx_muscle' in muscle:   muscle_L0[muscle] = 0.4
            elif 'shoulder_joint_ext_muscle' in muscle:   muscle_L0[muscle] = 0.4
            elif 'wrist_joint_flx_muscle' in muscle:      muscle_L0[muscle] = 0.4
            elif 'wrist_joint_ext_muscle' in muscle:      muscle_L0[muscle] = 0.4

        joint_diam = {name: 0.03 for name in joint_list}
        for joint in joint_diam:
            if   'hip_joint' in muscle:        joint_diam[joint] = 0.04
            elif 'knee_joint' in muscle:       joint_diam[joint] = 0.04
            elif 'ankle_joint' in muscle:      joint_diam[joint] = 0.04
            elif 'scapula_joint' in muscle:    joint_diam[joint] = 0.04
            elif 'shoulder_joint' in muscle:   joint_diam[joint] = 0.04
            elif 'wrist_joint' in muscle:      joint_diam[joint] = 0.04

        # Initial sensory data read
        sense_port.write(bytearray([255]))
        for joint in potentiometer_data.keys():
            potentiometer_data[joint]   = np.frombuffer(sense_port.read(1), dtype=np.uint8)
            potentiometer_data_0[joint] = potentiometer_data[joint]
        for muscle in pressure_sensor_data.keys():
            pressure_sensor_data[muscle] = np.frombuffer(sense_port.read(1), dtype=np.uint8)
            pressure_sensor_data_0[muscle] = pressure_sensor_data[muscle]
        

        # Initial joint/muscle value calculation
        muscle_data(
            potentiometer_data_0,
            potentiometer_data,
            joint_ang,
            muscle_len,
            muscle_vel,
            muscle_ten,
            comm_dt,
            comm_index,
            joint_diam,
            muscle_L0,
            pressure_sensor_data_0,
            pressure_sensor_data)

    else:
        joint_ang  = {key: np.zeros(num_steps) for key in joint_list}
        muscle_len = {key: np.zeros(num_steps) for key in muscles_list}
        muscle_vel = {key: np.zeros(num_steps) for key in muscles_list}
        muscle_ten = {key: np.zeros(num_steps) for key in muscles_list}

        muscle_L0 = {key: 0 for key in  muscles_list}
        for joint in joint_ang.keys():
            joint_ang[joint][0] = mujoco_data.qpos[joint_indices[joint]]
        for muscle in muscle_len.keys():
            muscle_len[muscle][0] = mujoco_data.actuator_length[muscle_indices[muscle]]
            muscle_L0[muscle] = muscle_len[muscle][0]

    # --- Motoneuron Properties ---
    mn_gains = {name: 1.0 for name in muscles_list}
    for muscle in muscles_list:
        if   'hip_joint_ext_muscle' in muscle:        mn_gains[muscle] = 0.97
        elif 'hip_joint_flx_muscle' in muscle:        mn_gains[muscle] = 1.1
        elif 'knee_joint_ext_muscle' in muscle:       mn_gains[muscle] = 1.1
        elif 'knee_joint_flx_muscle' in muscle:       mn_gains[muscle] = 0.9
        elif 'ankle_joint_ext_muscle' in muscle:      mn_gains[muscle] = 0.95
        elif 'ankle_joint_flx_muscle' in muscle:      mn_gains[muscle] = 0.95
        elif 'scapula_joint_ext_muscle' in muscle:    mn_gains[muscle] = 0.97
        elif 'scapula_joint_flx_muscle' in muscle:    mn_gains[muscle] = 1.1
        elif 'shoulder_joint_ext_muscle' in muscle:   mn_gains[muscle] = 1.1
        elif 'shoulder_joint_flx_muscle' in muscle:   mn_gains[muscle] = 0.9
        elif 'wrist_joint_ext_muscle' in muscle:      mn_gains[muscle] = 0.95
        elif 'wrist_joint_flx_muscle' in muscle:      mn_gains[muscle] = 0.95

    act_lvl = {name: -65 for name in muscles_list}
    for muscle in muscles_list:
        if   'hip_joint_ext_muscle' in muscle:        act_lvl[muscle] = -70
        elif 'hip_joint_flx_muscle' in muscle:        act_lvl[muscle] = -70
        elif 'knee_joint_ext_muscle' in muscle:       act_lvl[muscle] = -70
        elif 'knee_joint_flx_muscle' in muscle:       act_lvl[muscle] = -70
        elif 'ankle_joint_ext_muscle' in muscle:      act_lvl[muscle] = -60
        elif 'ankle_joint_flx_muscle' in muscle:      act_lvl[muscle] = -60
        elif 'scapula_joint_ext_muscle' in muscle:    act_lvl[muscle] = -70
        elif 'scapula_joint_flx_muscle' in muscle:    act_lvl[muscle] = -70
        elif 'shoulder_joint_ext_muscle' in muscle:   act_lvl[muscle] = -70
        elif 'shoulder_joint_flx_muscle' in muscle:   act_lvl[muscle] = -70
        elif 'wrist_joint_ext_muscle' in muscle:      act_lvl[muscle] = -60
        elif 'wrist_joint_flx_muscle' in muscle:      act_lvl[muscle] = -60

    mn_indices = {}
    for ind, name in enumerate(muscles_list):
        if ind < 6:
            mn_indices[name] = ind
        elif 6 <= ind < 12:
            mn_indices[name] = ind + 6
        elif 12 <= ind < 18:
            mn_indices[name] = ind + 6*2
        else:
            mn_indices[name] = ind + 6*3

    # --- Video Rendering ---
    frames = []
    framerate = 60
    renderer = mujoco.Renderer(mujoco_sim, 920,1280)
    plt.figure()
    plt.imshow(sns_model.g_max_non)

    # --- Loop Timing Variables ---
    time_print    = 0
    time_sns      = 0
    time_spk      = 0
    time_mujo     = 0
    time_spkqueue = 0
    time_feed     = 0
    time_vid      = 0
    time_mark     = clock.perf_counter()

    # --- Spike and Sensory Data Buffers ---
    spk_packet  = np.array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], dtype=bool)

    # --- Serial Communication Handler ---
    t_mark          = clock.perf_counter()
    time_start      = clock.perf_counter()
    sys.stdout.write(f"\n\n\n\n")

    # =============================
    # Main Simulation Loop
    # =============================
    for i in range(1, num_steps):
        # --- Timing: Track time spent in each section ---
        time_print += clock.perf_counter() - time_mark
        time_mark  = clock.perf_counter()

        # --- Step SNS Models ---
        sns_sim_data[i, :] = sns_model(x=sns_inputs)
        time_sns += clock.perf_counter() - time_mark
        time_mark = clock.perf_counter()

        # --- Convert SNS output to spiking inputs ---
        for muscle in muscle_indices.keys():
            spk_inputs[muscle_indices[muscle]] = non_to_spk(x=sns_sim_data[i-1, mn_indices[muscle]], half_point=act_lvl[muscle])
        sns_spk_data[i, :] = spk_model(x=spk_inputs)
        spikes_raw = np.array(sns_spk_data[i, :], dtype=bool)
        time_spk += clock.perf_counter() - time_mark
        time_mark = clock.perf_counter()

        # --- Hardware Communication: Muscle Mutt ---
        if muscle_mutt:
            # Accumulate spikes for next comm event
            if np.any(spikes_raw): 
                spk_packet = spk_packet | spikes_raw

            # At comm interval, send spikes and receive sensory data
            if i * dt >= comm_index * comm_dt:                
                spk_msg_in_bytes = np.concatenate(([255], np.packbits(spk_packet)))
                # Wait for real time to match simulation
                time_now = clock.perf_counter()
                while time_now < dt * i + time_start:
                    time_sleep = ((dt * i + time_start) - time_now) * 0.9
                    clock.sleep(max(0.0001, time_sleep))
                    time_now = clock.perf_counter()
                # Send spikes
                for byte in spk_msg_in_bytes:
                    spike_port.write(bytes([byte]))
                clock.sleep(0.000001)
                spk_confirmation = np.frombuffer(spike_port.read(4), dtype=np.uint8)
                spk_packet = np.zeros_like(spk_packet, dtype=bool)
                # Get sensory data
                sense_port.write(bytearray([255]))
                for joint in potentiometer_data.keys():
                    potentiometer_data[joint] = np.frombuffer(sense_port.read(1), dtype=np.uint8)
                for muscle in pressure_sensor_data.keys():
                    pressure_sensor_data[muscle] = np.frombuffer(sense_port.read(1), dtype=np.uint8)

                # Update all muscle values
                muscle_data(
                    potentiometer_data_0,
                    potentiometer_data,
                    joint_ang,
                    muscle_len,
                    muscle_vel,
                    muscle_ten,
                    comm_dt,
                    comm_index,
                    joint_diam,
                    muscle_L0,
                    pressure_sensor_data_0,
                    pressure_sensor_data)
                
                # Sync MuJoCo viewer (Verify that the simulation reads is reading sensor data correctly.)

                # viewer.sync()
                
                # Print joint status to terminal
                sys.stdout.write(f"\033[{len(joint_ang.keys())}A")
                for joint in joint_ang.keys():
                    sys.stdout.write("\033[K")
                    sys.stdout.write(f"{joint:<18} = {joint_ang[joint][comm_index]}\n")
                comm_index += 1

        time_spkqueue += clock.perf_counter() - time_mark
        time_mark = clock.perf_counter()

        # --- Simulation Communication: MuJoCo ---
        if not muscle_mutt:
            for muscle in muscle_indices.keys():
                mujoco_data.act[muscle_indices[muscle]] = stim_to_act(sns_sim_data[i-1, mn_indices[muscle]] * mn_gains[muscle])
            for muscle in muscle_indices.keys():
                if sns_spk_data[i, muscle_indices[muscle]] == 1:
                    pulse_data[i:i+int(10 - 1), muscle_indices[muscle]] = 1
                mujoco_data.act[muscle_indices[muscle]] = pulse_data[i, muscle_indices[muscle]]
            mujoco.mj_step(mujoco_sim, mujoco_data)
            time[i] = mujoco_data.time
            for joint in joint_ang.keys():
                joint_ang[joint][i] = mujoco_data.qpos[joint_indices[joint]]
            for muscle in muscle_len.keys():
                muscle_len[muscle][i] = mujoco_data.actuator_length[muscle_indices[muscle]]
                muscle_vel[muscle][i] = mujoco_data.actuator_velocity[muscle_indices[muscle]]
                muscle_ten[muscle][i] = mujoco_data.actuator_force[muscle_indices[muscle]]
            
        # --- Choose Index Based on Control Loop Type ---
        feedback_index = comm_index - 1 if muscle_mutt else i

        # --- Convert Muscle Data to SNS Inputs ---
        L_hip_feedback = hip_inputs(muscle_len['L_hip_joint_ext_muscle'][feedback_index], muscle_len['L_hip_joint_flx_muscle'][feedback_index], muscle_vel['L_hip_joint_ext_muscle'][feedback_index], muscle_vel['L_hip_joint_flx_muscle'][feedback_index], muscle_ten['L_hip_joint_ext_muscle'][feedback_index], muscle_ten['L_hip_joint_flx_muscle'][feedback_index], muscle_L0['L_hip_joint_ext_muscle'], muscle_L0['L_hip_joint_flx_muscle'])
        R_hip_feedback = hip_inputs(muscle_len['R_hip_joint_ext_muscle'][feedback_index], muscle_len['R_hip_joint_flx_muscle'][feedback_index], muscle_vel['R_hip_joint_ext_muscle'][feedback_index], muscle_vel['R_hip_joint_flx_muscle'][feedback_index], muscle_ten['R_hip_joint_ext_muscle'][feedback_index], muscle_ten['R_hip_joint_flx_muscle'][feedback_index], muscle_L0['R_hip_joint_ext_muscle'], muscle_L0['R_hip_joint_flx_muscle'])
        L_knee_feedback = knee_inputs(muscle_len['L_knee_joint_ext_muscle'][feedback_index], muscle_len['L_knee_joint_flx_muscle'][feedback_index], muscle_vel['L_knee_joint_ext_muscle'][feedback_index], muscle_vel['L_knee_joint_flx_muscle'][feedback_index], muscle_ten['L_knee_joint_ext_muscle'][feedback_index], muscle_ten['L_knee_joint_flx_muscle'][feedback_index], muscle_L0['L_knee_joint_ext_muscle'], muscle_L0['L_knee_joint_flx_muscle'])
        R_knee_feedback = knee_inputs(muscle_len['R_knee_joint_ext_muscle'][feedback_index], muscle_len['R_knee_joint_flx_muscle'][feedback_index], muscle_vel['R_knee_joint_ext_muscle'][feedback_index], muscle_vel['R_knee_joint_flx_muscle'][feedback_index], muscle_ten['R_knee_joint_ext_muscle'][feedback_index], muscle_ten['R_knee_joint_flx_muscle'][feedback_index], muscle_L0['R_knee_joint_ext_muscle'], muscle_L0['R_knee_joint_flx_muscle'])
        L_ankle_feedback = ankle_inputs(muscle_len['L_ankle_joint_ext_muscle'][feedback_index], muscle_len['L_ankle_joint_flx_muscle'][feedback_index], muscle_vel['L_ankle_joint_ext_muscle'][feedback_index], muscle_vel['L_ankle_joint_flx_muscle'][feedback_index], muscle_ten['L_ankle_joint_ext_muscle'][feedback_index], muscle_ten['L_ankle_joint_flx_muscle'][feedback_index], muscle_L0['L_ankle_joint_ext_muscle'], muscle_L0['L_ankle_joint_flx_muscle'])
        R_ankle_feedback = ankle_inputs(muscle_len['R_ankle_joint_ext_muscle'][feedback_index], muscle_len['R_ankle_joint_flx_muscle'][feedback_index], muscle_vel['R_ankle_joint_ext_muscle'][feedback_index], muscle_vel['R_ankle_joint_flx_muscle'][feedback_index], muscle_ten['R_ankle_joint_ext_muscle'][feedback_index], muscle_ten['R_ankle_joint_flx_muscle'][feedback_index], muscle_L0['R_ankle_joint_ext_muscle'], muscle_L0['R_ankle_joint_flx_muscle'])
        L_scapula_feedback = scapula_inputs(muscle_len['L_scapula_joint_ext_muscle'][feedback_index], muscle_len['L_scapula_joint_flx_muscle'][feedback_index], muscle_vel['L_scapula_joint_ext_muscle'][feedback_index], muscle_vel['L_scapula_joint_flx_muscle'][feedback_index], muscle_ten['L_scapula_joint_ext_muscle'][feedback_index], muscle_ten['L_scapula_joint_flx_muscle'][feedback_index], muscle_L0['L_scapula_joint_ext_muscle'], muscle_L0['L_scapula_joint_flx_muscle'])
        R_scapula_feedback = scapula_inputs(muscle_len['R_scapula_joint_ext_muscle'][feedback_index], muscle_len['R_scapula_joint_flx_muscle'][feedback_index], muscle_vel['R_scapula_joint_ext_muscle'][feedback_index], muscle_vel['R_scapula_joint_flx_muscle'][feedback_index], muscle_ten['R_scapula_joint_ext_muscle'][feedback_index], muscle_ten['R_scapula_joint_flx_muscle'][feedback_index], muscle_L0['R_scapula_joint_ext_muscle'], muscle_L0['R_scapula_joint_flx_muscle'])
        L_shoulder_feedback = shoulder_inputs(muscle_len['L_shoulder_joint_ext_muscle'][feedback_index], muscle_len['L_shoulder_joint_flx_muscle'][feedback_index], muscle_vel['L_shoulder_joint_ext_muscle'][feedback_index], muscle_vel['L_shoulder_joint_flx_muscle'][feedback_index], muscle_ten['L_shoulder_joint_ext_muscle'][feedback_index], muscle_ten['L_shoulder_joint_flx_muscle'][feedback_index], muscle_L0['L_shoulder_joint_ext_muscle'], muscle_L0['L_shoulder_joint_flx_muscle'])
        R_shoulder_feedback = shoulder_inputs(muscle_len['R_shoulder_joint_ext_muscle'][feedback_index], muscle_len['R_shoulder_joint_flx_muscle'][feedback_index], muscle_vel['R_shoulder_joint_ext_muscle'][feedback_index], muscle_vel['R_shoulder_joint_flx_muscle'][feedback_index], muscle_ten['R_shoulder_joint_ext_muscle'][feedback_index], muscle_ten['R_shoulder_joint_flx_muscle'][feedback_index], muscle_L0['R_shoulder_joint_ext_muscle'], muscle_L0['R_shoulder_joint_flx_muscle'])
        L_wrist_feedback = wrist_inputs(muscle_len['L_wrist_joint_ext_muscle'][feedback_index], muscle_len['L_wrist_joint_flx_muscle'][feedback_index], muscle_vel['L_wrist_joint_ext_muscle'][feedback_index], muscle_vel['L_wrist_joint_flx_muscle'][feedback_index], muscle_ten['L_wrist_joint_ext_muscle'][feedback_index], muscle_ten['L_wrist_joint_flx_muscle'][feedback_index], muscle_L0['L_wrist_joint_ext_muscle'], muscle_L0['L_wrist_joint_flx_muscle'])
        R_wrist_feedback = wrist_inputs(muscle_len['R_wrist_joint_ext_muscle'][feedback_index], muscle_len['R_wrist_joint_flx_muscle'][feedback_index], muscle_vel['R_wrist_joint_ext_muscle'][feedback_index], muscle_vel['R_wrist_joint_flx_muscle'][feedback_index], muscle_ten['R_wrist_joint_ext_muscle'][feedback_index], muscle_ten['R_wrist_joint_flx_muscle'][feedback_index], muscle_L0['R_wrist_joint_ext_muscle'], muscle_L0['R_wrist_joint_flx_muscle'])
        time_mujo += clock.perf_counter() - time_mark
        time_mark = clock.perf_counter()
        # --- Concatenate all feedback for SNS input ---
        L_sns_inputs_hind = np.concatenate((L_hip_feedback, L_knee_feedback, L_ankle_feedback, cpg_inputs[i,:]))
        R_sns_inputs_hind = np.concatenate((R_hip_feedback, R_knee_feedback, R_ankle_feedback, cpg_inputs[i,:]))
        L_sns_inputs_fore = np.concatenate((L_scapula_feedback, L_shoulder_feedback, L_wrist_feedback, cpg_inputs[i,:]))
        R_sns_inputs_fore = np.concatenate((R_scapula_feedback, R_shoulder_feedback, R_wrist_feedback, cpg_inputs[i,:]))
        sns_inputs = np.concatenate((R_sns_inputs_hind, L_sns_inputs_hind, R_sns_inputs_fore, L_sns_inputs_fore))
        time_feed += clock.perf_counter() - time_mark
        time_mark = clock.perf_counter()

        # --- Video Frame Rendering ---
        if make_vid:
            if len(frames) < mujoco_data.time * framerate:
                renderer.update_scene(mujoco_data, camera='close')
                pixels = renderer.render().copy()
                frames.append(pixels)
        time_vid += clock.perf_counter() - time_mark
        time_mark = clock.perf_counter()

    ###################################################################################
    ############################ Misc. Post-loop Actions ##############################
    ###################################################################################
    time_loop = clock.perf_counter() - time_start   # Calculate the actual simulation time

    if make_vid == True:
        media.write_video('full_hindlimb_sim.mp4', frames, fps=framerate)

    # cost = plot_gaits(time, joint_ang)
    plot_length(time, muscle_len)
    plot_velocity(time, muscle_vel)
    plot_joint(time, joint_ang)
    plot_sns(t, sns_sim_data.T)
    # plot_spk(t, sns_spk_data.T)
    plot_joint_muscle_summary(joint_ang, muscle_len, muscle_vel, muscle_ten)
    
    times = [time_print, time_sns, time_spk, time_spkqueue, time_mujo, time_feed, time_vid, time_loop]
    plot_times(times)

    # teensy_queue.put(None)
    # teensy_thread.join()
    
    sns_sim_data = sns_sim_data.T
    plt.figure()
    plt.plot(t, sns_sim_data[:][0], color='red')
    plt.plot(t, sns_sim_data[:][1], color='green')
    plt.plot(t, sns_sim_data[:][12], color='red', ls='--')
    plt.plot(t, sns_sim_data[:][13], color='green', ls='--')

    spike_port.flush()
    sense_port.flush()

    return # cost

def main():
    """
    Runs a simulation of rat hindlimbs movement using a Two-layer CPG SNS integrated with a Mujoco physics engine.

    This function sets up parameters such as simulation duration (`end_time`), time step (`dt`), Mujoco XML model path (`xml_path`), 
    and neural network inputs (`cpg_inputs`). It then calls the `run_sims()` function to perform the simulation and save the results.

    Parameters:
    None

    Returns:
    None

    Sets up threads which run synthetic nervous system.

    Functions:
    sim_thread: runs the simulation containing the SNS
    dat_thread: handles data receiving and sending between the simulation and Teensy
    """

    feed_fwd    = True
    muscle_mutt = True
    make_vid    = False

    spike_port_name = "/dev/cu.usbmodem164372401" # port to send spikes to the Teensy
    sense_port_name = "/dev/cu.usbmodem157539901" # port from Teensy which obtains sense data
    xml_path = 'python/quadruped_model.xml' # quadruped robot mujoco model path

    cpg_gsyn = 1.7  # defines RG oscillation speed (small adjustments make a big difference!)
    end_time = 20    # simulation end seconds
    dt = 1/1000     # simulation step size (1 ms is pretty large)
    num_steps = int(end_time/dt)    # Do not edit
    comm_freq = 60
    num_comms = int(comm_freq * end_time)
    Iapp =  np.zeros([num_steps,1]) # Do not edit
    Ipert = np.zeros([num_steps,1]) # Do not edit
    Ipert[1] = 1 # kick start the rhythm generators
    cpg_inputs = Iapp + Ipert       # Do not edit

    cost = run_sims(dt=dt, 
                    num_steps=num_steps, 
                    end_time=end_time, 
                    comm_freq=comm_freq,
                    num_comms=num_comms,
                    xml_path=xml_path, 
                    cpg_inputs=cpg_inputs, 
                    cpg_gsyn=cpg_gsyn, 
                    feed_forward=feed_fwd,
                    muscle_mutt=muscle_mutt,
                    make_vid=make_vid,
                    spike_port_name=spike_port_name,
                    sense_port_name=sense_port_name)
    return cost


if __name__ == '__main__':
    print("\n")
    print("... Program Started")
    main()
    print("\n", "... Simulation and Storage Complete")
    print("\n")
    # print(muscle_indeces)
    # plt.show()